---
title: 'Null and undefined'
metaTitle: 'Null and undefined (Reference)'
metaDescription: 'How Prisma Client handles null and undefined, including a GraphQL use case.'
preview: false
---

<TopBlock>

Prisma Client differentiates between `null` and `undefined`:

- `null` is a **value**
- `undefined` means **do nothing**

<Admonition type="info">

This is particularly important to account for in [a **Prisma with GraphQL context**, where `null` and `undefined` are interchangeable](#use-case-null-and-undefined-in-a-graphql-resolver).

</Admonition>

The data below represents a `User` table. This set of data will be used in all of the examples below:

| id  | name    | email             |
| --- | ------- | ----------------- |
| 1   | Nikolas | nikolas@gmail.com |
| 2   | Martin  | martin@gmail.com  |
| 3   | _empty_ | sabin@gmail.com   |
| 4   | Tyler   | tyler@gmail.com   |

</TopBlock>

<!-- TODO Simple example with `findMany` and `findFirst` that shows how a query with `foo: undefined` (e.g. https://github.com/prisma/prisma/issues/17723) returns everything or any first entry as it is filtered out of the query -->

## <inlinecode>null</inlinecode> and <inlinecode>undefined</inlinecode> in queries that affect _many_ records

This section will cover how `undefined` and `null` values in the filters of a query affect these functions:

- `findMany`
- `updateMany`
- `deleteMany`
- `count`
- `aggregate`
- `groupBy`

Consider the following Prisma Client query which searches for any user whose `name` column's value matches the provided value:

```ts
const users = await prisma.user.findMany({
  where: {
    name: null,
  },
})
```

Because `null` was provided as the filter criteria for the `name` column, Prisma Client will generate a query that searches for any records in the `User` table whose `name` column is _empty_.

The results of the query will be:

```json
[
  {
    "id": 3,
    "name": null,
    "email": "sabin@gmail.com"
  }
]
```

Now consider the scenario where you invoke the same query, except `undefined` is used as the filter criteria:

```ts
const users = await prisma.user.findMany({
  where: {
    name: undefined,
  },
})
```

When `undefined` is used in this way, you essentially tell Prisma Client you have decided _not to define a filter_ for that column. An equivalent way to write the above query would be:

```ts
const users = await prisma.user.findMany()
```

This query will select every row from the `User` table.

The resulting dataset from the query using `undefined` as the filter criteria will contain the entire set of users:

```json
[
  {
    "id": 1,
    "name": "Nikolas",
    "email": "nikolas@gmail.com"
  },
  {
    "id": 2,
    "name": "Martin",
    "email": "martin@gmail.com"
  },
  {
    "id": 3,
    "name": null,
    "email": "sabin@gmail.com"
  },
  {
    "id": 4,
    "name": "Tyler",
    "email": "tyler@gmail.com"
  }
]
```

Although this section's examples focused on the `findMany` function, the same concepts apply to any function that can affect multiple records, such as `updateMany` and `deleteMany`.

## <inlinecode>null</inlinecode> and <inlinecode>undefined</inlinecode> in queries that affect _one_ record

This section will cover how `undefined` and `null` values in the filter of a query affect these functions:

- `findFirst`
- `findFirstOrThrow`
- `findUnique`
- `findUniqueOrThrow`
- `delete`
- `update`
- `upsert`

<Admonition type="warning">

`null` is not a valid filter value in a `findUnique` query.

</Admonition>

The query behavior when using `null` and `undefined` in the filter criteria of a query that affects a single record is very similar to the behaviors described in the previous section.

Consider the following query:

```ts
const user = await prisma.user.findFirst({
  where: {
    name: null,
  },
})
```

Because `null` was used as the filter on the `name` column, Prisma Client will generate a query that searches for the first record in the `User` table whose `name` value is empty.

The result of either of the query above will be as follows:

```json
[
  {
    "id": 3,
    "name": null,
    "email": "sabin@gmail.com"
  }
]
```

If `undefined` is instead used as the filter criteria on the `name` column, the query will act as if no filter criteria was passed to that column at all.

Consider the query below:

```ts
const user = await prisma.user.findFirst({
  where: {
    name: undefined,
  },
})
```

Another way to represent the above query is:

```ts
const user = await prisma.user.findFirst()
```

In this scenario, the query will return the very first record in the database. The results will be:

```json
[
  {
    "id": 1,
    "name": "Nikolas",
    "email": "nikolas@gmail.com"
  }
]
```

Although this section's examples focused on the `findFirst` function, the same concepts apply to any function that affects a single record.

## <inlinecode>null</inlinecode> and <inlinecode>undefined</inlinecode> in a GraphQL resolver

For this example, consider a database based on the following Prisma schema:

```prisma
model User {
  id    Int     @id @default(autoincrement())
  email String  @unique
  name  String?
}
```

In the following GraphQL mutation that updates a user, both `authorEmail` and `name` accept `null`. From a GraphQL perspective, this means that fields are **optional**:

```ts
type Mutation {
  // Update author's email or name, or both - or neither!
  updateUser(id: Int!, authorEmail: String, authorName: String): User!
}
```

However, if you pass `null` values for `authorEmail` or `authorName` on to Prisma, the following will happen:

- If `args.authorEmail` is `null`, the query will **fail**. `email` does not accept `null`.
- If `args.authorName` is `null`, Prisma changes the value of `name` to `null`. This is probably not how you want an update to work.

```ts
updateUser: (parent, args, ctx: Context) => {
  return ctx.prisma.user.update({
    where: { id: Number(args.id) },
    data: {
|      email: args.authorEmail, // email cannot be null
|      name: args.authorName // name set to null - potentially unwanted behavior
    },
  })
},
```

Instead, set the value of `email` and `name` to `undefined` if the input value is `null`. Doing this is the same as not updating the field at all:

```ts
updateUser: (parent, args, ctx: Context) => {
  return ctx.prisma.user.update({
    where: { id: Number(args.id) },
    data: {
|      email: args.authorEmail != null ? args.authorEmail : undefined, // If null, do nothing
|      name: args.authorName != null ? args.authorName : undefined // If null, do nothing
    },
  })
},
```

## The effect of <inlinecode>null</inlinecode> and <inlinecode>undefined</inlinecode> on conditionals

There are some caveats to filtering with conditionals which might produce unexpected results. When filtering with conditionals you might expect one result but receive another given how Prisma treats nullable values.

The following table provides a high-level overview of how the different operators handle 0, 1 and `n` filters.

| Operator | 0 filters         | 1 filter               | n filters            |
| -------- | ----------------- | ---------------------- | -------------------- |
| `OR`     | return empty list | validate single filter | validate all filters |
| `AND`    | return all items  | validate single filter | validate all filters |
| `NOT`    | return all items  | validate single filter | validate all filters |

This example shows how an `undefined` parameter impacts the results returned by a query that uses the [`OR`](/reference/api-reference/prisma-client-reference#or) <span class="api"></span> operator.

```ts
interface FormData {
  name: string
  email?: string
}

const formData: FormData = {
  name: 'Emelie',
}

const users = await prisma.user.findMany({
  where: {
    OR: [
      {
        email: {
          contains: formData.email,
        },
      },
    ],
  },
})

// returns: []
```

The query receives filters from a formData object, which includes an optional email property. In this instance, the value of the email property is `undefined`. When this query is run no data is returned.

This is in contrast to the [`AND`](/reference/api-reference/prisma-client-reference#and) <span class="api"></span> and [`NOT`](/reference/api-reference/prisma-client-reference#not-1) <span class="api"></span> operators, which will both return all the users
if you pass in an `undefined` value.

> This is because passing an `undefined` value to an `AND` or `NOT` operator is the same
> as passing nothing at all, meaning the `findMany` query in the example will run without any filters and return all the users.

```ts
interface FormData {
  name: string
  email?: string
}

const formData: FormData = {
  name: 'Emelie',
}

const users = await prisma.user.findMany({
  where: {
    AND: [
      {
        email: {
          contains: formData.email,
        },
      },
    ],
  },
})

// returns: { id: 1, email: 'ems@boop.com', name: 'Emelie' }

const users = await prisma.user.findMany({
  where: {
    NOT: [
      {
        email: {
          contains: formData.email,
        },
      },
    ],
  },
})

// returns: { id: 1, email: 'ems@boop.com', name: 'Emelie' }
```
