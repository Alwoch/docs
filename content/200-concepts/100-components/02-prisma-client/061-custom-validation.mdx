---
title: 'Custom validation'
metaTitle: 'Custom validation'
metaDescription: 'This page explains how to add custom validation to Prisma Client'
---

<TopBlock>

You can add runtime validation for your user input for Prisma Client queries in one of the following ways:

- [Prisma Client extensions](/concepts/components/prisma-client/client-extensions)
- A custom function

You can use any validation library you'd like. The Node.js ecosystem offers a number of high-quality, easy-to-use validation libraries to choose from including: [joi](https://github.com/sideway/joi), [validator.js](https://github.com/validatorjs/validator.js), [Yup](https://github.com/jquense/yup), [Zod](https://github.com/colinhacks/zod) and [Superstruct](https://github.com/ianstormtaylor/superstruct).

</TopBlock>

## Input validation with Prisma Client extensions

> Prisma Client extensions are currently in [Preview](/about/prisma/releases#preview).

This example adds runtime validation when creating and updating values using a Zod schema to check that the data passed to Prisma Client is valid.

<Admonition>

Query extensions do not currently work for nested operations. In this example, validations are only run on the top level data object passed to methods such as `prisma.product.create()`. Validations implemented this way do not automatically run for [nested writes](https://www.prisma.io/docs/concepts/components/prisma-client/relation-queries#nested-writes).

</Admonition>

<TabbedContent tabs={[ <FileWithIcon text="Prisma Client extension" icon="file"/>, <FileWithIcon text="Prisma schema" icon="file"/>]}>

<tab>

```ts copy
import { PrismaClient } from "@prisma/client";
import { z } from 'zod'
import { type Prisma } from '@prisma/client'

const PostCreateInput = z.object({
  title: z.string(),
  published: z.boolean().default(false),
  content: z.string().nullable(),
  authorId: z.number().nullable(),
}) satisfies z.Schema<Prisma.PostUncheckedCreateInput>

/**
 * Prisma Client Extension
 */
const prisma = new PrismaClient().$extends({
  query: {
    post: {
      create({ args, query }) {
        args.data = PostCreateInput.parse(args.data)
        return query(args)
      },
      update({ args, query }) {
        args.data = PostCreateInput.partial().parse(args.data)
        return query(args)
      },
      updateMany({ args, query }) {
        args.data = PostCreateInput.partial().parse(args.data)
        return query(args)
      },
      upsert({ args, query }) {
        args.create = PostCreateInput.parse(args.create)
        args.update = PostCreateInput.parse(args.update)
        return query(args)
      }
    }
  }
})

async function main (){
  /**
   * Example usage
   */

  // A post with invalid input — missing the title field
  const invalidPost = await prisma.post.create({
    data: {
      content: 'Prisma Client: extended!',
    },
  })

  // A post with valid input
  const validPost = await prisma.post.create({
    data: {
      title: 'Prisma Client extensions',
      content: 'Prisma Client: extended!',
    },
  })
}

main()
```

</tab>

<tab>

```prisma copy
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["clientExtensions"]
}

model User {
  id    Int     @id @default(autoincrement())
  email String  @unique
  name  String?

  posts Post[]
}

model Post {
  id        Int     @id @default(autoincrement())
  title     String
  published Boolean @default(true)
  content   String?

  authorId Int?
  author   User? @relation(fields: [authorId], references: [id])
}
```

</tab>

</TabbedContent>

## Input validation with a custom validation function

Here's an example using [Superstruct](https://github.com/ianstormtaylor/superstruct) to validate that the data needed to signup a new user is correct:

```tsx
import { PrismaClient, Prisma, User } from '@prisma/client'
import { assert, object, string, size, refine } from 'superstruct'
import isEmail from 'isemail'

const prisma = new PrismaClient()

// Runtime validation
const Signup = object({
  // string and a valid email address
  email: refine(string(), 'email', (v) => isEmail.validate(v)),
  // password is between 7 and 30 characters long
  password: size(string(), 7, 30),
  // first name is between 2 and 50 characters long
  firstName: size(string(), 2, 50),
  // last name is between 2 and 50 characters long
  lastName: size(string(), 2, 50),
})

type Signup = Omit<Prisma.UserCreateArgs['data'], 'id'>

// Signup function
async function signup(input: Signup): Promise<User> {
  // Assert that input conforms to Signup, throwing with a helpful
  // error message if input is invalid.
  assert(input, Signup)
  return prisma.user.create({
    data: input.user,
  })
}
```

The example above shows how you can create a custom type-safe `signup` function that ensures the input is valid before creating a user.

## Going further

- Learn how you can use [Prisma Client extensions](/concepts/components/prisma-client/client-extensions) to add input validation for your queries — [example](https://github.com/prisma/prisma-client-extensions/tree/main/input-validation).
- Learn how you can organize your code better by moving the `signup` function into [a custom model](/concepts/components/prisma-client/custom-models).
- There's an [outstanding feature request](https://github.com/prisma/prisma/issues/3528) to bake user validation into Prisma Client. If you'd like to see that happen, make sure to upvote that issue and share your use case!
